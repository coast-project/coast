import os, socket, shutil, pdb
import threading
import SConsider
from stat import *
from SocketServer import BaseServer, TCPServer, BaseRequestHandler
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
from SimpleHTTPServer import SimpleHTTPRequestHandler

Import('*')

class MyTCPServer(TCPServer):
    """This class wrapper is needed to set allow_reuse_address to True
    prior to initializing it"""
    allow_reuse_address = True

class MyHTTPServer(HTTPServer):
    """This class wrapper is needed to set allow_reuse_address to True
    prior to initializing it"""
    allow_reuse_address = True

class AcceptorHandler(BaseRequestHandler):
    def handle(self):
        data = self.request.recv(1024)
        self.request.send('')

class HTTPHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()

class NoSendRecvHandler(BaseRequestHandler):
    def handle(self):
        pass

servers = []
def startServer(host, port, server_class, handler_class):
    server = server_class((host, port), handler_class)
    servers.append(server)
    server.serve_forever()

tcpnosendrecvport=43000
tcpsendrecvport=43001
httpsendrecvport=43002
fqdn=socket.getfqdn()
hostonly=fqdn.split('.')[0]
try:
    domain='.'.join(fqdn.split('.')[1:])
except:
    domain=""
faultyfqdn='nonexisting.server.loc'
localhostname='localhost'
localhostip=socket.gethostbyname(localhostname)
hosttoresolvename='www.hsr.ch'
try:
    hosttoresolveip=socket.gethostbyname(hosttoresolvename)
except:
    hosttoresolvename=localhostname
    hosttoresolveip=localhostip

searchReplace = {
    'FQDN': fqdn,
    'FAULTYFQDN': faultyfqdn,
    'HOSTNAME': hostonly,
    'HOSTNAMEIP': socket.gethostbyname(hostonly),
    'DOMAINONLY': domain,
    'TCPNOSENDRECVPORT': str(tcpnosendrecvport),
    'TCPSENDRECVPORT': str(tcpsendrecvport),
    'HTTPSENDRECVPORT': str(httpsendrecvport),
    'DIREXTENDBASEDIR': lambda env: os.path.join(env['BASEOUTDIR'].Dir(env['RELTARGETDIR']).abspath, 'makedirextendtest', 'test'),
    'LOCALHOSTNAME': localhostname,
    'LOCALHOSTIP': localhostip,
    'RESOLVABLEHOSTFQDN': hosttoresolvename,
    'RESOLVABLEHOSTIP': hosttoresolveip,
    'TMPDIR': lambda env: 'c:/temp' if str(env['PLATFORM']) == 'cygwin' else '/tmp',
    'ROOTFS': lambda env: 'c:/' if str(env['PLATFORM']) == 'cygwin' else '/',
}

def SystemTestMakeDirectoryExtendCleanup(env):
    tdirabs = env['BASEOUTDIR'].Dir(env['RELTARGETDIR']).abspath
    basepath = os.path.join(tdirabs, 'makedirextendtest')
    if os.path.isdir(basepath):
        shutil.rmtree(basepath, ignore_errors=True)

def setUp(target, source, env):
    # setup listener threads for socket tests
    threading.Thread(target=startServer, args=[localhostname, tcpsendrecvport, MyTCPServer, AcceptorHandler]).start()
    threading.Thread(target=startServer, args=[localhostname, httpsendrecvport, MyHTTPServer, HTTPHandler]).start()
    threading.Thread(target=startServer, args=[localhostname, tcpnosendrecvport, MyTCPServer, NoSendRecvHandler]).start()
    #env['ENV']['COAST_LOGONCERR'] = '1'

def tearDown(target, source, env):
    for server in servers:
        server.shutdown()
    # delete generated files
    SConsider.removeFiles(SConsider.findFiles([env['BASEOUTDIR'].Dir(env['RELTARGETDIR'])], extensions=['.res'], matchfiles=['include.any']))
    SystemTestMakeDirectoryExtendCleanup(env)

buildSettings = {
    'Base' : {
        'linkDependencies' : ['CoastFoundation.Base', 'CoastFoundation.Time', 'testfwFoundation'],
        'sourceFiles'      : SConsider.listFiles(['base/*.cpp']),
        'targetType'       : 'ProgramTest',
        'copyFiles'        : [
            (SConsider.listFiles(['base/config/*.any']), S_IRUSR | S_IRGRP | S_IROTH, searchReplace),
            (SConsider.listFiles(['base/config/*.tst', 'base/config/*.txt', 'base/tmp/*']), S_IRUSR | S_IRGRP | S_IROTH),
        ],
        'appendUnique'     : {
            'ENV': { 'COAST_PATH' : '.:base:base/config' }
        },
    },
    'Time' : {
        'linkDependencies' : ['CoastFoundation.Time', 'testfwFoundation'],
        'sourceFiles'      : SConsider.listFiles(['time/*.cpp']),
        'targetType'       : 'ProgramTest',
        'copyFiles'        : [
            (SConsider.listFiles(['time/config/*.any']), S_IRUSR | S_IRGRP | S_IROTH, searchReplace),
        ],
        'appendUnique'     : {
            'ENV': { 'COAST_PATH' : '.:time/config' }
        },
    },
    'IO' : {
        'linkDependencies' : ['CoastFoundation.IO', 'CoastFoundation.Miscellaneous', 'testfwFoundation'],
        'sourceFiles'      : SConsider.listFiles(['io/*.cpp']),
        'targetType'       : 'ProgramTest',
        'copyFiles'        : [
            (SConsider.listFiles(['io/config/*.any']), S_IRUSR | S_IRGRP | S_IROTH, searchReplace),
            (SConsider.listFiles(['io/config/*.sh']), S_IRUSR | S_IRGRP | S_IROTH | S_IXUSR),
        ],
        'appendUnique'     : {
            'ENV': { 'COAST_PATH' : '.:io/config' }
        },
        'runConfig'        : {
            'setUp'        : setUp,
            'tearDown'     : tearDown,
        },
    },
    'Miscellaneous' : {
        'linkDependencies' : ['CoastFoundation.Miscellaneous', 'testfwFoundation'],
        'sourceFiles'      : SConsider.listFiles(['miscellaneous/*.cpp']),
        'targetType'       : 'ProgramTest',
        'copyFiles'        : [
            (SConsider.listFiles(['miscellaneous/config/*.any']), S_IRUSR | S_IRGRP | S_IROTH, searchReplace),
        ],
        'appendUnique'     : {
            'ENV': { 'COAST_PATH' : '.:miscellaneous/config' }
        },
    },
    'AnythingOptional' : {
        'linkDependencies' : ['CoastFoundation.AnythingOptional', 'testfwFoundation'],
        'sourceFiles'      : SConsider.listFiles(['anythingoptional/*.cpp']),
        'targetType'       : 'ProgramTest',
        'copyFiles'        : [
            (SConsider.listFiles(['anythingoptional/config/*.any']), S_IRUSR | S_IRGRP | S_IROTH, searchReplace),
        ],
        'appendUnique'     : {
            'ENV': { 'COAST_PATH' : '.:anythingoptional:anythingoptional/config' }
        },
    }
}

SConsider.createTargets(packagename, buildSettings)

import SConsider
import os, socket, pdb, re
import threading, shutil, asyncore
from stat import *
import ServerExtensions
from BaseHTTPServer import HTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler
from OpenSSL import SSL, crypto
from SomeUtils import runCommand

Import('*')

class SMTPThread(threading.Thread):
    def __init__(self, host, port, path, logfile):
        super(SMTPThread, self).__init__()
        self.smtpd = ServerExtensions.SMTPFileSinkServer((host, port), None, path, logfile)
        self.daemon = True

    def run(self):
        asyncore.loop()

class MyHTTPServer(HTTPServer):
    """This class wrapper is needed to set allow_reuse_address to True
    prior to initializing it"""
    allow_reuse_address = True

smtpport=43020
smtpfaultyport=43021
httpport=43022
faultyhttpport=43023
sslport=43024
sslfaultyport=43025
cport1=43031
cport2=43032
cport3=43033
hostonly, domain, fqdn = SConsider.getfqdn()

def appendReplaceCommandForCert(key, filename, searchReplace):
    try:
        data = open(filename)
        x509 = crypto.load_certificate(crypto.FILETYPE_PEM, data.read())
        data.close()
        complist=x509.get_subject().get_components()
        complist.reverse()
        outname=key+'_subject'
        searchReplace.append((r"##"+outname+"##",','.join([k+'='+v for k,v in complist])));
        searchReplace.append((r"##"+outname+"_parts##",' '.join(['"'+k+'='+v+'"' for k,v in complist])));
        complist=x509.get_issuer().get_components()
        complist.reverse()
        outname=key+'_issuer'
        searchReplace.append((r"##"+outname+"##",','.join([k+'='+v for k,v in complist])));
    except:pass

def ModifyConfigFiles(env, searchReplace=[], files=[]):
    for file in files:
        fname = file.abspath
        if os.path.isfile(fname):
            oldmode=os.stat(fname).st_mode
            ## set writable
            os.chmod(fname, oldmode | S_IWUSR)
            ## replace tokens in file
            SConsider.replaceRegexInFile(fname, searchReplace)
            os.chmod(fname, oldmode)

servers = []
def startServer(host, port, server_class, handlerOrRemote=None, **kw):
    server = server_class((host, port), handlerOrRemote, **kw)
    servers.append(server)
    server.serve_forever()

def prepareMkCaParams(env, commandargs, tdirabs, certdir):
    mkcaScriptName = os.path.join(tdirabs, 'mkca-new.sh')
    ## set writable cfgfilename
    targets = SConsider.packageRegistry.getPackageTarget('openssl', 'openSSL')
    target = targets['target']
    if not os.path.isfile(mkcaScriptName):
        return False
    commandargs.extend([mkcaScriptName])
    if target:
        commandargs.extend(['-b', target.abspath])
        commandargs.extend(['-B', '-S --'])
    cnfFilename=os.path.join(tdirabs, 'openssl.cnf')
    if cnfFilename:
        commandargs.extend(['-o', cnfFilename])
    mkcertDirectory = os.path.join(tdirabs, 'mkcertdir')
    certOutDir = os.path.join(tdirabs, certdir)
    for theDir in [mkcertDirectory, certOutDir]:
        if os.path.isdir(theDir):
            shutil.rmtree(theDir, ignore_errors=True)
        os.mkdir(theDir)
    commandargs.extend(['-d', mkcertDirectory])
    # maybe we should do the following step by hand because we do not need cert suffixes
    commandargs.extend(['-c', certOutDir])
    commandargs.extend(['-C', hostonly])
    commandargs.extend(['-S', hostonly])
    if domain:
        commandargs.extend(['-S', fqdn])

def createCertificates(env):
    tdir = env['BASEOUTDIR'].Dir(env['RELTARGETDIR'])
    commandargs=[]
    stdincontent=[]
    certdir='cert_files'
    certOutDir = os.path.join(tdir.abspath, certdir)
    prepareMkCaParams(env, commandargs, tdir.abspath, certdir)
    logpath = tdir.Dir(os.path.join(env['LOGDIR'], env['VARIANTDIR']))
    retCode=runCommand(commandargs, logpath=logpath.abspath, stdincontent='\n'.join(stdincontent))
    certFileNodesList=[]
    certDict={}
    if retCode == 0:
        # get list of copied certificates
        certFileNodesList=SConsider.findFiles([certOutDir], ['.pem','.p12'])
        certDict=createCertDict(certFileNodesList)
        targets = SConsider.packageRegistry.getPackageTarget('openssl', 'openSSL')
        target = targets['target']
        sslbin='openssl'
        if target:
            sslbin=''+target.abspath+' -S --'
        # if there is now c_rehash available, use the following improved script, (base from from http://www.commandlinefu.com/commands/view/2532/c_rehash-replacement)
        command='for file in *crt*.pem; do theHash=`'+sslbin+' x509 -hash -noout -in $file 2>/dev/null` && test ! -f ${theHash}.0 && ln -s $file ${theHash}.0; done'
        retCode=runCommand(command, logpath=logpath.abspath, stdincontent=None, shell=True, cwd=certOutDir)
    return (certOutDir, certFileNodesList, certDict)

def createCertDict(certFileNodesList):
    certDict={}
    for cname in ['servercrt', 'serverkey', 'clientcrt', 'clientkey', 'fullchain', 'serverchain','chainwoservercrt', 'subCA1crt', 'subCA1key', 'rootCA1crt', 'rootCA1key']:
        try:
            filename=[c.abspath for c in certFileNodesList if re.match(r''+cname+'(_'+hostonly+')?\.pem', os.path.split(c.abspath)[1])][0]
            certDict[cname]=filename
        except: pass
    return certDict

def setUp(target, source, env):
    tdir = env['BASEOUTDIR'].Dir(env['RELTARGETDIR'])
    tdirabs = tdir.abspath
    logpath = tdir.Dir(os.path.join(env['LOGDIR'], env['VARIANTDIR']))
    configdir = tdir.Dir('config')

    # create certificate files
    certOutDir,certFileNodesList,certDict=createCertificates(env)
    if certDict:
        searchReplace = [
            (r"##FQDN##", fqdn),
            (r"##HOSTNAME##", hostonly),
            (r"##DOMAINONLY##", domain),
            (r"##HTTPPORT##", str(httpport)),
            (r"##CPORT1##", str(cport1)),
            (r"##CPORT2##", str(cport2)),
            (r"##CPORT3##", str(cport3)),
            (r"##FAULTYHTTPPORT##", str(faultyhttpport)),
            (r"##SSLPORT##", str(sslport)),
            (r"##FAULTYSSLPORT##", str(sslfaultyport)),
            (r"##SMTPPORT##", str(smtpport)),
            (r"##SMTPFAULTYPORT##", str(smtpfaultyport)),
        ]
        for key,value in certDict.items():
            searchReplace.append((r"##"+key+"_abs##",value));
            searchReplace.append((r"##"+key+"_rel##",os.path.relpath(value, tdirabs)));
            if key.endswith('crt'):
                appendReplaceCommandForCert(key, value, searchReplace)
        searchReplace.append((r"##certdir_abs##",certOutDir));
        searchReplace.append((r"##certdir_rel##",os.path.relpath(certOutDir, tdirabs)));
        ModifyConfigFiles(env, searchReplace, SConsider.findFiles([configdir],['.any']))
        threading.Thread(target=startServer, args=[hostonly, sslport, ServerExtensions.SecureHTTPServer, ServerExtensions.SecureHTTPRequestHandler], kwargs={'certFile':certDict.get('servercrt'), 'keyFile':certDict.get('serverkey'), 'caChainFile':certDict.get('chainwoservercrt')}).start()
        threading.Thread(target=startServer, args=[hostonly, httpport, MyHTTPServer, SimpleHTTPRequestHandler]).start()
        SMTPThread(hostonly, smtpport, env['BASEOUTDIR'].Dir(env['RELTARGETDIR']).Dir(env['LOGDIR']).Dir(env['VARIANTDIR']).abspath, 'smtp.log').start()

    #FIXME: the following setting is needed to let CgiCallerTest succeed
    env['ENV']['COAST_ROOT'] = env['BASEOUTDIR'].Dir(env['RELTARGETDIR']).abspath
    env['ENV']['COAST_LOGONCERR'] = 2
#    env['ENV']['COAST_PATH'] = ':'.join(['config', '.'])

def tearDown(target, source, env):
    for server in servers:
        server.shutdown()
    # delete generated files
#    SConsider.removeFiles(SConsider.findFiles([env['BASEOUTDIR'].Dir(env['RELTARGETDIR'])], extensions=['.res', '.tst', '.txt' ], matchfiles=['include.any']))

buildSettings = {
    packagename : {
        'targetType'       : 'ProgramTest',
        'linkDependencies' : ['CoastStdDataAccess', 'testfwWDBase'],
        'requires'         : ['openssl.openSSL', 'CoastRenderers'],
		'includeSubdir'    : '',
        'sourceFiles'      : SConsider.listFiles( ['*.cpp'] ),
        'copyFiles' : [
            ( SConsider.findFiles( ['.'], extensions=['.sh'] ), S_IRUSR | S_IRGRP | S_IROTH | S_IXUSR ),
            ( SConsider.findFiles( ['.'], extensions=['.any', '.html', '.gif', '.txt'] ), S_IRUSR | S_IRGRP | S_IROTH ),
            ( SConsider.findFiles( ['config'], matchfiles=['NotReadable'] ), S_IXUSR ),
            ( SConsider.findFiles( ['.'], matchfiles=['openssl.cnf'] ), S_IRUSR | S_IRGRP | S_IROTH ),
            ( SConsider.findFiles( ['.'], matchfiles=['mkca-new.sh'] ), S_IRUSR | S_IRGRP | S_IROTH | S_IXUSR ),
        ],
        'runConfig' : {
            'setUp'        : setUp,
            'tearDown'     : tearDown,
        },
    }
}

SConsider.createTargets( packagename, buildSettings )

